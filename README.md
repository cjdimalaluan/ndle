NDLE Ascent - Spaced Repetition Study AppVersion: 2.0.0Last Updated: July 1, 20251. Project OverviewNDLE Ascent is a responsive, single-page web application designed as a powerful study tool for students preparing for the Philippine Nutritionist-Dietitian Licensure Exam (NDLE). The application's core is a multiple-choice quiz system powered by a spaced repetition system (SRS) algorithm to maximize learning efficiency and long-term retention.The project is built to be easily hosted on static platforms like GitHub Pages and uses Firebase for user data persistence, ensuring that each user's progress is saved across sessions.Core Features:Spaced Repetition System (SRS): Intelligently schedules questions based on user performance (Again, Good, Easy) to optimize study time.Decoupled & Versioned Database: Questions are managed in external JSON files, allowing for easy updates without redeploying the core application. The app automatically fetches new questions for all users when a database version is updated.Firebase Backend: Securely stores user-specific data, including study progress for each card and any user-created cards.Anonymous Authentication: Users can start studying immediately without creating an account. Progress is tied to a unique, anonymous user ID managed by Firebase Auth.Fully Responsive & Accessible: Designed with a mobile-first approach and built with semantic HTML and ARIA attributes for a seamless experience on any device and for users of assistive technologies.2. Technology StackFrontend:HTML5: Semantic structure using modern tags like <main>, <section>, and <dialog>.CSS3: Styled with Tailwind CSS for a utility-first workflow. Includes CSS Custom Properties for easy theming.JavaScript (ES6+): All logic is handled in a single vanilla JavaScript module. No frameworks are used.Backend & Database:Firebase Firestore: A NoSQL cloud database to store user-specific card progress and custom-added cards.Firebase Authentication: For handling anonymous user sessions.Hosting:Designed for GitHub Pages or any other static site hosting service.3. Core Concepts & Architecture3.1. Spaced Repetition System (SRS)The SRS is the intellectual core of the app. It is a simplified, effective implementation based on the principles of increasing recall intervals.Card State: Each card in a user's Firestore database has two key SRS properties: interval (in days) and nextReviewDate.Review Queue: A study session is composed of all cards where nextReviewDate is today or in the past, plus a limited number of "new" cards (those with no SRS properties yet).User Feedback & Interval Calculation:Again: The card was difficult. The interval is reset to 1 day. The card is also pushed to the back of the current study queue to be seen again shortly.Good: The user remembered, but with some effort. The current interval is multiplied by a factor of 2 (e.g., 4 days -> 8 days).Easy: The user knew it instantly. The current interval is multiplied by a factor of 4 (e.g., 4 days -> 16 days).This logic is handled in the processReview() function.3.2. Decoupled Database & VersioningTo allow for continuous content updates without affecting user data, the master question bank is decoupled from the application code.External JSON Files: The master questions are stored in subject-specific JSON files (ffss_questions.json, etc.) hosted in the GitHub repository.Per-Subject Versioning: Each JSON file contains a version key (e.g., "1.0"). This is the master version for that subject.User Profile in Firestore: Each user has a profile/main document in their Firestore data. This document stores a dbVersions map, which records the last database version they have synced for each subject (e.g., { ffss: "1.0", nbcd: "1.1" }).Automatic Update Check: On application startup, the checkForDBUpdates() function is triggered. It fetches each remote JSON file, compares its version with the user's corresponding version from their profile, and if the remote version is newer, it adds all questions from that file to the user's cards collection in Firestore.This architecture ensures that updates are seamless and non-destructive. A content manager can simply update a JSON file, increment its version number, and all users will automatically receive the new questions on their next visit.4. Getting Started (Developer Setup)Follow these steps to set up a local development environment.PrerequisitesGitA code editor (e.g., VS Code)A Firebase account (the free "Spark Plan" is sufficient)Step-by-Step Installation1. Clone the Repositorygit clone [https://github.com/your-username/your-repo-name.git](https://github.com/your-username/your-repo-name.git)
cd your-repo-name
2. Create a Firebase ProjectGo to the Firebase Console.Click "Add project" and give your project a name (e.g., "ndle-ascent-dev").Once created, navigate to the Firestore Database section.Click "Create database".Start in Test Mode. This sets the initial security rules to be open for development. Note: These rules must be secured before a public launch.Choose a Firestore location (e.g., asia-southeast1).3. Get Firebase ConfigurationIn your Firebase project, click the Gear icon (Project settings).In the "General" tab, scroll to "Your apps".Click the web icon (</>) to register a new web app.Give it a nickname (e.g., "NDLE Ascent Web") and click "Register app".Firebase will provide a firebaseConfig object. Copy this entire object.4. Configure index.htmlOpen the index.html file in your code editor.Find the initializeFirebase function within the <script> tag.Paste your firebaseConfig object, replacing the placeholder.Update the DB_CONFIG URLs to point to your local files for development or to your raw GitHub URLs for production. For local development, you can simply use the relative file paths:const CONSTANTS = {
    // ...
    DB_CONFIG: {
        'nbcd': { url: "./nbcd_questions.json" },
        'ffss': { url: "./ffss_questions.json" },
        'cphn': { url: "./cphn_questions.json" }
    }
};
5. Run a Local ServerBecause the app uses ES Modules and fetch, you cannot open index.html directly in the browser from the file system. You must serve it.A simple way is to use the Live Server extension in VS Code.Install the Live Server extension.Right-click on index.html in the VS Code explorer and select "Open with Live Server".Your application should now be running locally and connected to your Firebase project.5. Database ManagementUpdating the question bank is the most common maintenance task.How to Add/Edit/Remove QuestionsOpen the relevant JSON file (e.g., ffss_questions.json).Edit the questions array. Each question is an object that must adhere to the following structure:{
  "question": "Your question text here.",
  "options": {
    "a": "Option A",
    "b": "Option B",
    "c": "Option C",
    "d": "Option D"
  },
  "correctAnswer": "c",
  "rationale": "A detailed explanation of why the correct answer is right and others are wrong.",
  "tags": ["Topic", "Year"]
}
How to Push Updates to UsersAfter modifying the questions in a JSON file, you must increment the version number at the top of that file. Use semantic versioning (e.g., 1.0 -> 1.1 for minor additions, 1.1 -> 2.0 for major overhauls).Commit and push the updated JSON file to your GitHub repository.That's it. The checkForDBUpdates() function in the app will handle the rest, ensuring users get the new content automatically.6. Code Architecture Deep Diveindex.htmlSemantic HTML: The document uses <header>, <main>, <section>, and <dialog> to create a meaningful and accessible structure. This is crucial for screen readers.Performance Directives: <link rel="preconnect"> and <link rel="preload"> are used in the <head> to give the browser hints about critical resources, allowing it to fetch them earlier and improve load times.Accessibility:The <dialog> element is used for modals, providing out-of-the-box features like Esc to close and better focus management.aria-live="polite" is used on the study session container to announce to screen readers when a new question has been loaded.aria-label is used on icon-only buttons for clarity.CSS (<style> block)CSS Custom Properties: A :root block defines the primary color palette. This makes global theme changes easy and ensures consistency.@apply Directive: Tailwind's @apply is used sparingly to create a few component-level classes (e.g., .btn, .btn-primary) for cleaner HTML and to group common utility combinations.JavaScript (<script type="module">)CONSTANTS Object: A single, capitalized object at the top holds all static configuration data (subject names, keys, colors, database URLs). This prevents "magic strings" and makes configuration changes safe and easy.initializeFirebase(): Handles the connection to Firebase. It now contains the firebaseConfig object that must be filled in by the developer.checkForDBUpdates(): The core of the versioning system. It iterates through the DB_CONFIG, fetches each remote database, compares versions, and writes new questions to Firestore using a writeBatch for efficiency.setupRealtimeListener(): Uses onSnapshot to create a live connection to the user's cards collection in Firestore. Any change in the database (e.g., a card's nextReviewDate being updated) is immediately reflected in the UI.Modal Handling: The code uses dialog.showModal() and dialog.close() to control the accessible <dialog> elements. This is the modern, recommended approach over toggling CSS classes.7. ContributingContributions are welcome! Please follow these steps:Fork the repository.Create a new branch for your feature or bugfix (git checkout -b feature/my-new-feature).Make your changes, adhering to the existing code style.Commit your changes (git commit -m 'Add some feature').Push to your branch (git push origin feature/my-new-feature).Open a Pull Request with a clear description of the changes.8. LicenseThis project is licensed under the MIT License. See the LICENSE file for details.
